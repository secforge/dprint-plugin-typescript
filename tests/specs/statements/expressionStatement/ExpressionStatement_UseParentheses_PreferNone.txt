~~ expressionStatement.useParentheses: preferNone ~~
== should keep parentheses around object literal (disambiguation required) ==
({
    prop: value
});

[expect]
({
    prop: value,
});

== should keep parentheses around function expression (disambiguation required) ==
(function test() {
    return 1;
});

[expect]
(function test() {
    return 1;
});

== should NOT add parentheses around arrow function ==
() => 42;

[expect]
() => 42;

== should remove parentheses around arrow function ==
(() => 42);

[expect]
() => 42;

== should NOT add parentheses around simple identifier (not supported) ==
someVariable;

[expect]
someVariable;

== should NOT add parentheses around call expression (not supported) ==
someFunction();

[expect]
someFunction();

== should remove parentheses around call expression ==
(someFunction());

[expect]
someFunction();

== should NOT add parentheses around member expression (not supported) ==
obj.prop;

[expect]
obj.prop;

== should NOT add parentheses around array literal (not supported) ==
[1, 2, 3];

[expect]
[1, 2, 3];

== should NOT add parentheses around template literal (not supported) ==
`hello world`;

[expect]
`hello world`;

== should NOT add parentheses around binary expression (not supported) ==
a + b;

[expect]
a + b;

== should remove parentheses around binary expression ==
(a + b);

[expect]
a + b;

== should remove redundant outer parens from nested binary expressions ==
((a || b) && c);

[expect]
(a || b) && c;

== should remove redundant outer parens from simple expression ==
(value);

[expect]
value;

== should keep parentheses that affect operator precedence ==
((a + b) * c);

[expect]
(a + b) * c;

== should keep parentheses around arrow function used as callee ==
(() => 42)();

[expect]
(() => 42)();

== should keep parentheses around arrow function used in optional chain ==
(() => 42)?.prop;

[expect]
(() => 42)?.prop;

== should keep parentheses around arrow function with type assertion ==
(() => 42) as NumberFunction;

[expect]
(() => 42) as NumberFunction;

== should remove parentheses around await expression ==
(await value());

[expect]
await value();

== should remove parentheses around unary expression ==
(+value);

[expect]
+value;

== should remove parentheses around prefix increment ==
+(value);

[expect]
+value;

== should remove parentheses around new expression ==
(new Foo());

[expect]
new Foo();

== should remove parentheses around optional chain expression ==
(obj?.prop);

[expect]
obj?.prop;

== should remove parentheses around nullish coalescing expression ==
(a ?? b);

[expect]
a ?? b;

== should keep parentheses around object literal with as assertion ==
({}) as Foo;

[expect]
({}) as Foo;

== should keep parentheses around object literal with satisfies assertion ==
({}) satisfies Foo;

[expect]
({}) satisfies Foo;

== should keep parentheses around object literal with as const assertion ==
({}) as const;

[expect]
({}) as const;

== should NOT add parentheses around object literal with type assertion ==
<Foo>{};

[expect]
<Foo> {};

== should keep parentheses around object literal with non-null assertion ==
({})!;

[expect]
({})!;

== should keep parentheses around object literal with multiple assertions ==
({}) as Foo as Bar;

[expect]
({}) as Foo as Bar;

== should keep parentheses around function expression with as assertion ==
(function() {}) as Foo;

[expect]
(function() {}) as Foo;

== should keep parentheses around function expression with satisfies assertion ==
(function() {}) satisfies Foo;

[expect]
(function() {}) satisfies Foo;

== should keep parentheses around function expression with as const assertion ==
(function() {}) as const;

[expect]
(function() {}) as const;

== should keep parentheses around function expression with non-null assertion ==
(function() {})!;

[expect]
(function() {})!;

== should keep parentheses around function expression with multiple assertions ==
(function() {}) as Foo as Bar;

[expect]
(function() {}) as Foo as Bar;

== should NOT add parentheses around arrow function with as assertion ==
(() => 42) as Foo;

[expect]
(() => 42) as Foo;

== should NOT add parentheses around call expression with as assertion ==
foo() as Bar;

[expect]
foo() as Bar;

== should keep parentheses around nested object literal with assertions ==
({prop: {}}) as Foo;

[expect]
({ prop: {} }) as Foo;

== should keep parentheses around object literal used as member expression base ==
({}).foo;

[expect]
({}).foo;

== should keep parentheses around object literal used as call expression callee ==
({})();

[expect]
({})();

== should keep parentheses around object literal used as optional chain base ==
({})?.prop;

[expect]
({})?.prop;

== should keep parentheses around function expression used as member expression base ==
(function() {}).foo;

[expect]
(function() {}).foo;

== should keep parentheses around function expression used as call expression callee ==
(function() {})();

[expect]
(function() {})();

== should keep parentheses around function expression used as optional chain base ==
(function() {})?.prop;

[expect]
(function() {})?.prop;

== should keep parentheses with mixed assertion wrappers on object literal ==
({})! as Foo;

[expect]
({})! as Foo;

== should keep parentheses with mixed assertion wrappers on function expression ==
(function() {})! as Foo;

[expect]
(function() {})! as Foo;

== should keep parentheses with chained mixed assertions on object literal ==
({}) as Foo satisfies Bar;

[expect]
({}) as Foo satisfies Bar;

== should keep parentheses with chained mixed assertions on function expression ==
(function() {}) as Foo satisfies Bar;

[expect]
(function() {}) as Foo satisfies Bar;

== should remove redundant outer parens from nested assertion chains on object literal ==
(({} as X) as Y);

[expect]
({} as X) as Y;

== should remove redundant outer parens from nested assertion chains on function expression ==
((function() {}) as X) as Y;

[expect]
(function() {}) as X as Y;

== should remove redundant outer parens from nested assertion chains on class expression ==
((class {}) as X) as Y;

[expect]
(class {}) as X as Y;

== should keep parentheses around sequence expression ==
(a, b);

[expect]
(a, b);

== should keep parentheses around anonymous class expression ==
(class {});

[expect]
(class {});

== should keep parentheses around named class expression ==
(class Foo {});

[expect]
(class Foo {});

== should keep parentheses around class expression with as assertion ==
(class {}) as Foo;

[expect]
(class {}) as Foo;

== should keep parentheses around class expression with satisfies assertion ==
(class {}) satisfies Foo;

[expect]
(class {}) satisfies Foo;

== should keep parentheses around class expression with as const assertion ==
(class {}) as const;

[expect]
(class {}) as const;

== should keep parentheses around class expression with non-null assertion ==
(class {})!;

[expect]
(class {})!;

== should keep parentheses around class expression with multiple assertions ==
(class {}) as Foo as Bar;

[expect]
(class {}) as Foo as Bar;

== should keep parentheses with mixed assertion wrappers on class expression ==
(class {})! as Foo;

[expect]
(class {})! as Foo;

== should keep parentheses around class expression with chained mixed assertions ==
(class {}) as Foo satisfies Bar;

[expect]
(class {}) as Foo satisfies Bar;

== should keep parentheses around class expression used as member expression base ==
(class {}).foo;

[expect]
(class {}).foo;

== should keep parentheses around class expression used as call expression callee ==
(class {})();

[expect]
(class {})();

== should keep parentheses around class expression used as optional chain base ==
(class {})?.prop;

[expect]
(class {})?.prop;
