~~ useParentheses: maintain ~~
== should retain multi-line parentheses in expression statement without comment ==
if (a)
  (f
    ());

[expect]
if (a) {
    (f());
}

== should keep multi-line parentheses in expression statement with comment ==
if (a)
  (f //
    ());

[expect]
if (a) {
    (f //
    ());
}

== should retain multi-line parentheses in return without comment ==
if (a)
  return (f
    ());

[expect]
if (a) {
    return (f());
}

== should keep multi-line parentheses in return with comment ==
if (a)
  return (f //
    ());

[expect]
if (a) {
    return (f //
    ());
}

== should retain multi-line parentheses in return with function call on next line ==
if (a)
  return (f
(veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongIdentifierName1234567890123456789012345678901234567890));

[expect]
if (a) {
    return (f(
        veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongIdentifierName1234567890123456789012345678901234567890,
    ));
}

== should retain multi-line parentheses around long variable in return ==
return (
  veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongIdentifierName1234567890123456789012345678901234567890);

[expect]
return (
    veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongIdentifierName1234567890123456789012345678901234567890
);

== should retain multi-line parentheses in throw without comment ==
if (a)
  throw (f
    ());

[expect]
if (a) {
    throw (f());
}

== should keep multi-line parentheses in throw with comment ==
if (a)
  throw (f //
    ());

[expect]
if (a) {
    throw (f //
    ());
}

== should retain multi-line parentheses in yield without comment ==
function* gen() {
  if (a)
    yield (f
      ());
}

[expect]
function* gen() {
    if (a) {
        yield (f());
    }
}

== should keep multi-line parentheses in yield with comment ==
function* gen() {
  if (a)
    yield (f //
      ());
}

[expect]
function* gen() {
    if (a) {
        yield (f //
        ());
    }
}

== should keep multi-line parentheses in call argument with comment ==
foo((arg //
));

[expect]
foo(
    (
        arg //
    ),
);

== should retain multi-line parentheses in call argument without comment ==
foo((arg
));

[expect]
foo((arg));

== should keep multi-line parentheses in array element with comment ==
[(item //
)];

[expect]
[
    (
        item //
    ),
];

== should retain multi-line parentheses in array element without comment ==
[(item
)];

[expect]
[(item)];

== should use parentheses for object literal expression statement ==
({ foo: 1 });

[expect]
({ foo: 1 });

== should keep multi-line parentheses around optional chain object with comment ==
(f //
)?.prop;

[expect]
(
    f //
)?.prop;

== should retain multi-line parentheses around optional chain object without comment ==
(f
)?.prop;

[expect]
(f)?.prop;

== should keep multi-line parentheses with comment before optional chain member access ==
(f //
?.prop);

[expect]
(f //
    ?.prop);

== should retain multi-line parentheses around optional chain member access without comment ==
(f
?.prop);

[expect]
(f
    ?.prop);

== should keep multi-line parentheses around member access object with comment ==
(f //
).prop;

[expect]
(
    f //
).prop;

== should retain multi-line parentheses around member access object without comment ==
(f
).prop;

[expect]
(f).prop;

== should keep multi-line parentheses with comment before member access ==
(f //
.prop);

[expect]
(f //
    .prop);

== should retain multi-line parentheses around member access without comment ==
(f
.prop);

[expect]
(f
    .prop);

== should keep multi-line parentheses around call callee with comment ==
(f //
)();

[expect]
(
    f //
)();

== should retain multi-line parentheses around call callee without comment ==
(f
)();

[expect]
(f)();

== should keep multi-line parentheses with comment before call ==
(f //
());

[expect]
(f //
());

== should retain multi-line parentheses around call without comment ==
(f
());

[expect]
(f());

== should keep multi-line parentheses around optional call callee with comment ==
(f //
)?.();

[expect]
(
    f //
)?.();

== should retain multi-line parentheses around optional call callee without comment ==
(f
)?.();

[expect]
(f)?.();

== should keep multi-line parentheses with comment before optional chain ==
(f //
?.());

[expect]
(f //
?.());

== should retain multi-line parentheses around optional chain call without comment ==
(f
?.());

[expect]
(f?.());

== TEST: single line array access should retain parens ==
(a[2]);

[expect]
(a[2]);

== should keep multi-line parentheses around call expression ==
(f //
());

[expect]
(f //
());

== should keep multi-line parentheses around function callee ==
(f //
)();

[expect]
(
    f //
)();

== should remove parentheses inside call arguments ==
f((1 + 2));

[expect]
f((1 + 2));

== should remove parentheses inside return statement ==
function test() {
    return (value);
}

[expect]
function test() {
    return (value);
}

== should keep parentheses when they affect operator precedence ==
const result = (a + b) * c;

[expect]
const result = (a + b) * c;

== should retain parentheses that enforce grouping ==
const ambiguous = a / (b * c);

[expect]
const ambiguous = a / (b * c);

== should remove parentheses that do not affect precedence ==
const precedenceOk = (a * b) + c;

[expect]
const precedenceOk = (a * b) + c;

== should remove parentheses in ternary branches ==
const value = condition ? (left) : (right);

[expect]
const value = condition ? (left) : (right);

== should remove parentheses inside array elements ==
const items = [(value), ((other))];

[expect]
const items = [(value), ((other))];

== should retain parentheses in array destructuring pattern when required ==
const [value = (await load())] = source;

[expect]
const [value = (await load())] = source;

== should remove parentheses inside object properties ==
const obj = {
    prop: (value),
    nested: ((other)),
};

[expect]
const obj = {
    prop: (value),
    nested: ((other)),
};

== should keep parentheses around object literal arrow body ==
const arrow = () => ({ value: 1 });

[expect]
const arrow = () => ({ value: 1 });

== should remove parentheses inside template expression ==
const message = `hello ${ (name) }`;

[expect]
const message = `hello ${(name)}`;

== should remove parentheses around optional chaining ==
const maybe = (obj?.prop);

[expect]
const maybe = (obj?.prop);

== should retain parentheses around optional chaining when combined with exponentiation ==
const complex = (obj?.value) ** 2;

[expect]
const complex = (obj?.value) ** 2;

== should keep parentheses around function expression callees ==
const iifeResult = (function () {})();

[expect]
const iifeResult = (function() {})();

== should keep parentheses around optional chained function expression callees ==
const optionalIife = (function () {})?.();

[expect]
const optionalIife = (function() {})?.();

== should keep parentheses around optional chained arrow callees ==
const optionalArrowIife = (() => {})?.();

[expect]
const optionalArrowIife = (() => {})?.();

== should remove redundant parens in nested optional arrow calls ==
const nestedOptionalArrow = ((() => {})?.())?.();

[expect]
const nestedOptionalArrow = ((() => {})?.())?.();

== should keep parentheses around optional chained class expression callees ==
const optionalClassIife = (class {})?.();

[expect]
const optionalClassIife = (class {})?.();

== should keep parentheses around optional chained class expression property access ==
const optionalClassProp = (class { constructor() { this.prop = 1; } })?.prop;

[expect]
const optionalClassProp = (class {
    constructor() {
        this.prop = 1;
    }
})?.prop;

== should keep parentheses around optional chained function expression property access ==
const optionalFuncProp = (function () {})?.prop;

[expect]
const optionalFuncProp = (function() {})?.prop;

== should keep parentheses around optional chained arrow function property access ==
const optionalArrowProp = (() => {})?.prop;

[expect]
const optionalArrowProp = (() => {})?.prop;

== should keep parentheses around multi-line function expression property access ==
const functionPropMultiline = (function () {}
    ).prop;

[expect]
const functionPropMultiline = (function() {}).prop;

== should keep parentheses around multi-line class expression property access ==
const classPropMultiline = (class {}
    ).prop;

[expect]
const classPropMultiline = (class {}).prop;

== should keep parentheses around multi-line arrow function property access ==
const arrowPropMultiline = (() => {}
    ).prop;

[expect]
const arrowPropMultiline = (() => {}).prop;

== should keep parentheses around multi-line optional chained function property access ==
const optionalFunctionPropMultiline = (function () {}
    )?.prop;

[expect]
const optionalFunctionPropMultiline = (function() {})?.prop;

== should keep parentheses around multi-line optional chained function property access with comment ==
const optionalFunctionPropMultilineComment = (function () {}
    )?.prop; // comment

[expect]
const optionalFunctionPropMultilineComment = (function() {})?.prop; // comment

== should keep parentheses around multi-line optional chained arrow call ==
const optionalArrowCallMultiline = (() => {}
    )?.();

[expect]
const optionalArrowCallMultiline = (() => {})?.();

== should keep parentheses around multi-line optional chained function call ==
const optionalFunctionCallMultiline = (function () {}
    )?.();

[expect]
const optionalFunctionCallMultiline = (function() {})?.();

== should remove redundant parens around optional chained new expression access ==
const optionalNewProp = (new Foo())?.prop;

[expect]
const optionalNewProp = (new Foo())?.prop;

== should keep parentheses around multi-line optional chained new expression access ==
const optionalNewPropMultiline = (new Foo
    ())?.prop;

[expect]
const optionalNewPropMultiline = (new Foo())?.prop;

== should remove parentheses around nullish coalescing inside assignments ==
const fallback = (primary ?? secondary);

[expect]
const fallback = (primary ?? secondary);

== should remove parentheses around await inside expressions ==
async function load() {
    const data = (await fetchData());
}

[expect]
async function load() {
    const data = (await fetchData());
}

== should keep parentheses around awaited call when accessing members ==
async function useData() {
    return (await loadData()).map(item => item);
}

[expect]
async function useData() {
    return (await loadData()).map(item => item);
}

== should remove parentheses around yield expression ==
function* gen() {
    yield (value);
}

[expect]
function* gen() {
    yield (value);
}

== should retain parentheses around yield used in expression ==
function* collect() {
    const collected = [ (yield value) ];
}

[expect]
function* collect() {
    const collected = [(yield value)];
}

== should keep parentheses around yield when accessing members ==
function* project() {
    const result = (yield getValue()).prop;
}

[expect]
function* project() {
    const result = (yield getValue()).prop;
}

== should keep parentheses around multi-line yield expression ==
function* yieldMultiline() {
    yield (getGenerator
        ());
}

[expect]
function* yieldMultiline() {
    yield (getGenerator());
}

== should keep parentheses around multi-line yield optional call ==
function* yieldOptionalMultiline() {
    return (yield getFactory
        ())?.();
}

[expect]
function* yieldOptionalMultiline() {
    return (yield getFactory())?.();
}

== should keep parentheses around multi-line yield property access ==
function* yieldPropertyMultiline() {
    return (yield getFactory
        ()).value;
}

[expect]
function* yieldPropertyMultiline() {
    return (yield getFactory()).value;
}

== should remove parentheses around throw expression ==
throw (error);

[expect]
throw (error);

== should keep parentheses around multi-line throw expression ==
function throwMultiline() {
    throw (createError
        ());
}

[expect]
function throwMultiline() {
    throw (createError());
}

== should keep parentheses around multi-line await expression in throw ==
async function throwAwaitMultiline() {
    throw (await createAsyncError
        ());
}

[expect]
async function throwAwaitMultiline() {
    throw (await createAsyncError());
}

== should keep parentheses around multi-line throw optional call ==
function throwOptionalMultiline() {
    throw (getFactory
        ())?.();
}

[expect]
function throwOptionalMultiline() {
    throw (getFactory())?.();
}

== should keep parentheses around multi-line throw property access ==
function throwPropertyMultiline() {
    throw (createError
        ()).code;
}

[expect]
function throwPropertyMultiline() {
    throw (createError()).code;
}

== should retain parentheses around throw in IIFE ==
const result = condition ? value : (() => { throw error; })();

[expect]
const result = condition ? value : (() => {
    throw error;
})();

== should remove parentheses around export default expression ==
export default (component);

[expect]
export default (component);

== should retain parentheses around export default when template literal ==
export default (`value`);

[expect]
export default (`value`);

== should remove parentheses in if condition ==
if ((condition)) {
    doSomething();
}

[expect]
if ((condition)) {
    doSomething();
}

== should keep parentheses around multi-line await in if condition ==
async function ifAwaitMultiline() {
    if ((await shouldProceed
        ())) {
        doSomething();
    }
}

[expect]
async function ifAwaitMultiline() {
    if ((await shouldProceed())) {
        doSomething();
    }
}

== should remove parentheses in while condition ==
while ((ready)) {
    run();
}

[expect]
while ((ready)) {
    run();
}

== should remove parentheses in do while condition ==
do {
    work();
} while ((shouldContinue));

[expect]
do {
    work();
} while ((shouldContinue));

== should keep parentheses around multi-line await in while condition ==
async function whileAwaitMultiline() {
    while ((await shouldContinue
        ())) {
        run();
    }
}

[expect]
async function whileAwaitMultiline() {
    while ((await shouldContinue())) {
        run();
    }
}

== should remove parentheses in for-of iterable ==
for (const item of (collection)) {
    consume(item);
}

[expect]
for (const item of (collection)) {
    consume(item);
}

== should keep parentheses around multi-line await in for-of iterable ==
async function forOfAwaitMultiline() {
    for (const item of (await loadItems
        ())) {
        consume(item);
    }
}

[expect]
async function forOfAwaitMultiline() {
    for (const item of (await loadItems())) {
        consume(item);
    }
}

== should remove parentheses in for head ==
for (let i = (0); i < (max); i++) {
    step(i);
}

[expect]
for (let i = (0); i < (max); i++) {
    step(i);
}

== should remove parentheses in switch discriminant and cases ==
switch ((value)) {
case (1):
    break;
}

[expect]
switch ((value)) {
    case (1):
        break;
}

== should remove parentheses around unary operations ==
const increment = (++(value));

[expect]
const increment = (++(value));

== should remove parentheses around typeof in binary expressions ==
const typeCheck = (typeof value) + " suffix";

[expect]
const typeCheck = (typeof value) + " suffix";

== should keep parentheses around delete when followed by member access ==
const deleteResult = (delete obj.prop).toString();

[expect]
const deleteResult = (delete obj.prop).toString();

== should keep parentheses around typeof when accessing members ==
const typeInfo = (typeof value).toUpperCase();

[expect]
const typeInfo = (typeof value).toUpperCase();

== should keep parentheses around void when accessing members ==
const voidInfo = (void 0).toString();

[expect]
const voidInfo = (void 0).toString();

== should remove parentheses in default parameter initializers ==
function configure(option = (defaultValue)) {}

[expect]
function configure(option = (defaultValue)) {}

== should remove parentheses inside logical expressions ==
const combined = (a && b) || (c && d);

[expect]
const combined = (a && b) || (c && d);

== should retain parentheses in logical expression when required ==
const precedence = a && (b || c);

[expect]
const precedence = a && (b || c);

== should remove parentheses around new expression ==
const instance = (new Foo());

[expect]
const instance = (new Foo());

== should retain parentheses around new with call when needed ==
const construct = (new Foo())();

[expect]
const construct = (new Foo())();

== should remove parentheses around typeof/void/delete ==
const info = {
    type: typeof (value),
    cleared: void (0),
    removed: delete (obj.prop),
};

[expect]
const info = {
    type: typeof (value),
    cleared: void (0),
    removed: delete (obj.prop),
};

== should remove parentheses around tagged template expressions ==
const tagged = tag((value));

[expect]
const tagged = tag((value));

== should remove parentheses inside class field initializer ==
class Example {
    value = (initial);
}

[expect]
class Example {
    value = (initial);
}

== should remove parentheses in array destructuring defaults ==
const [first = (fallback)] = source;

[expect]
const [first = (fallback)] = source;

== should remove parentheses in object destructuring defaults ==
const { value = (fallback) } = source;

[expect]
const { value = (fallback) } = source;

== should remove parentheses around dynamic import specifier ==
async function load() {
    return import((moduleName));
}

[expect]
async function load() {
    return import((moduleName));
}

== should retain parentheses around dynamic import with assertions ==
async function load() {
    return import(moduleName, { with: (options) });
}

[expect]
async function load() {
    return import(moduleName, { with: (options) });
}

== should remove parentheses around class heritage ==
class Derived extends (Base) {}

[expect]
class Derived extends (Base) {}

== should remove parentheses in super call ==
class Child extends Base {
    constructor() {
        super((arg));
    }
}

[expect]
class Child extends Base {
    constructor() {
        super((arg));
    }
}

== should remove parentheses around yield star expression ==
function* forward() {
    yield* (iterable);
}

[expect]
function* forward() {
    yield* (iterable);
}

== should keep parentheses around multi-line yield star expression ==
function* forwardMultiline() {
    yield* (getIterable
        ());
}

[expect]
function* forwardMultiline() {
    yield* (getIterable());
}

== should keep parentheses around sequence expressions ==
doSomething((a, b));

[expect]
doSomething((a, b));

== should remove parentheses around call expression results ==
const resultCall = (compute()) + 1;

[expect]
const resultCall = (compute()) + 1;

== should remove parentheses around expressions in for loop headers ==
for (let i = (0); i < (max); i++) {}

[expect]
for (let i = (0); i < (max); i++) {}

== should retain parentheses when mixing nullish coalescing with logical OR ==
const fallbackOr = (x ?? y) || z;

[expect]
const fallbackOr = (x ?? y) || z;

== should retain parentheses when mixing nullish coalescing with logical AND ==
const fallbackAnd = (x ?? y) && z;

[expect]
const fallbackAnd = (x ?? y) && z;

== should retain parentheses when mixing logical OR with nullish coalescing ==
const orWithNull = x || (y ?? z);

[expect]
const orWithNull = x || (y ?? z);

== should retain parentheses when mixing logical AND with nullish coalescing ==
const andWithNull = x && (y ?? z);

[expect]
const andWithNull = x && (y ?? z);

== should remove parentheses around delete in logical expressions ==
const deleteCheck = (delete obj.prop) && other;

[expect]
const deleteCheck = (delete obj.prop) && other;

== should remove parentheses around typeof in binary expressions ==
const typeCheck = (typeof value) + " suffix";

[expect]
const typeCheck = (typeof value) + " suffix";

== should remove parentheses around void in logical expressions ==
const voidCheck = (void 0) || fallback;

[expect]
const voidCheck = (void 0) || fallback;

== should keep parentheses around await in binary expressions ==
async function asyncBinary() {
    const result = (await fetch()) + 1;
}

[expect]
async function asyncBinary() {
    const result = (await fetch()) + 1;
}

== should remove redundant parentheses around await when returned ==
async function returnAwait(condition) {
    return (await resolveValue(condition));
}

[expect]
async function returnAwait(condition) {
    return (await resolveValue(condition));
}

== should keep parentheses around multi-line return call ==
function returnMultilineCall() {
    return (getFactory
        ());
}

[expect]
function returnMultilineCall() {
    return (getFactory());
}

== should keep parentheses around multi-line return call with comment ==
function returnMultilineCallWithComment() {
    return (createFactory // comment
        ());
}

[expect]
function returnMultilineCallWithComment() {
    return (createFactory // comment
    ());
}

== should keep parentheses around multi-line throw call with comment ==
function throwMultilineWithComment() {
    throw (createError // comment
        ());
}

[expect]
function throwMultilineWithComment() {
    throw (createError // comment
    ());
}

== should keep parentheses around multi-line await expression ==
async function awaitMultiline() {
    return (await loadData
        ()).map(item => item);
}

[expect]
async function awaitMultiline() {
    return (await loadData()).map(item => item);
}

== should keep parentheses around multi-line await optional call ==
async function awaitOptionalMultiline() {
    return (await loadFactory
        ())?.();
}

[expect]
async function awaitOptionalMultiline() {
    return (await loadFactory())?.();
}

== should keep parentheses around multi-line await binary expression ==
async function awaitBinaryMultiline() {
    const total = (await computeValue
        ()) + 1;
    return total;
}

[expect]
async function awaitBinaryMultiline() {
    const total = (await computeValue()) + 1;
    return total;
}

== should keep parentheses around multi-line return property access ==
function returnPropertyMultiline() {
    return (getObject
        ()).value;
}

[expect]
function returnPropertyMultiline() {
    return (getObject()).value;
}

== should keep parentheses around multi-line return optional call ==
function returnOptionalMultiline() {
    return (getCallback
        ())?.();
}

[expect]
function returnOptionalMultiline() {
    return (getCallback())?.();
}

== should keep parentheses around multi-line return property access with comment ==
function returnPropertyMultilineComment() {
    return (getObject // comment
        ()).value;
}

[expect]
function returnPropertyMultilineComment() {
    return (getObject // comment
    ()).value;
}

== should remove redundant parentheses around await in ternary expressions ==
async function asyncTernary() {
    const value = condition ? (await foo()) : bar;
}

[expect]
async function asyncTernary() {
    const value = condition ? (await foo()) : bar;
}

== should retain parentheses around yield in binary expressions ==
function* yieldBinary() {
    const result = (yield value) + 1;
}

[expect]
function* yieldBinary() {
    const result = (yield value) + 1;
}

== should keep parentheses around multi-line yield binary expression ==
function* yieldBinaryMultiline() {
    const result = (yield computeValue
        ()) + 1;
    return result;
}

[expect]
function* yieldBinaryMultiline() {
    const result = (yield computeValue()) + 1;
    return result;
}

== should remove redundant parens around member access on await in ternary condition ==
async function ternaryAccess(cond) {
    return ((await fetchData()).value) ? (await fetchData()).value : defaultValue;
}

[expect]
async function ternaryAccess(cond) {
    return ((await fetchData()).value) ? (await fetchData()).value : defaultValue;
}

== should keep parentheses around object literal (disambiguation required) ==
({
    prop: value
});

[expect]
({
    prop: value,
});

== should keep parentheses around function expression (disambiguation required) ==
(function test() {
    return 1;
});

[expect]
(function test() {
    return 1;
});

== should NOT add parentheses around arrow function ==
() => 42;

[expect]
() => 42;

== should keep simple call expression statement ==
foo();

[expect]
foo();

== should keep await expression statement ==
async function run() {
    await doSomething();
}

[expect]
async function run() {
    await doSomething();
}

== should remove parentheses around arrow function ==
(() => 42);

[expect]
(() => 42);

== should NOT add parentheses around simple identifier (not supported) ==
someVariable;

[expect]
someVariable;

== should NOT add parentheses around call expression (not supported) ==
someFunction();

[expect]
someFunction();

== should remove parentheses around call expression ==
(someFunction());

[expect]
(someFunction());

== should NOT add parentheses around member expression (not supported) ==
obj.prop;

[expect]
obj.prop;

== should NOT add parentheses around array literal (not supported) ==
[1, 2, 3];

[expect]
[1, 2, 3];

== should NOT add parentheses around template literal (not supported) ==
`hello world`;

[expect]
`hello world`;

== should NOT add parentheses around binary expression (not supported) ==
a + b;

[expect]
a + b;

== should remove parentheses around binary expression ==
(a + b);

[expect]
(a + b);

== should remove redundant outer parens from nested binary expressions ==
((a || b) && c);

[expect]
((a || b) && c);

== should remove redundant outer parens from simple expression ==
(value);

[expect]
(value);

== should keep parentheses that affect operator precedence ==
((a + b) * c);

[expect]
((a + b) * c);

== should keep parentheses around arrow function used as callee ==
(() => 42)();

[expect]
(() => 42)();

== should keep parentheses around arrow function used in optional chain ==
(() => 42)?.prop;

[expect]
(() => 42)?.prop;

== should keep parentheses around arrow function with type assertion ==
(() => 42) as NumberFunction;

[expect]
(() => 42) as NumberFunction;

== should remove parentheses around await expression ==
(await value());

[expect]
(await value());

== should remove parentheses around unary expression ==
(+value);

[expect]
(+value);

== should remove parentheses around prefix increment ==
+(value);

[expect]
+(value);

== should remove parentheses around new expression ==
(new Foo());

[expect]
(new Foo());

== should remove parentheses around optional chain expression ==
(obj?.prop);

[expect]
(obj?.prop);

== should remove parentheses around nullish coalescing expression ==
(a ?? b);

[expect]
(a ?? b);

== should keep parentheses around object literal with as assertion ==
({}) as Foo;

[expect]
({}) as Foo;

== should keep parentheses around object literal with satisfies assertion ==
({}) satisfies Foo;

[expect]
({}) satisfies Foo;

== should keep parentheses around object literal with as const assertion ==
({}) as const;

[expect]
({}) as const;

== should NOT add parentheses around object literal with type assertion ==
<Foo>{};

[expect]
<Foo> {};

== should keep parentheses around object literal with non-null assertion ==
({})!;

[expect]
({})!;

== should keep parentheses around object literal with multiple assertions ==
({}) as Foo as Bar;

[expect]
({}) as Foo as Bar;

== should keep parentheses around object literal with as assertion inside while loop ==
while (true) {
    ({} as X);
}

[expect]
while (true) {
    ({} as X);
}

== should keep parentheses around function expression with as assertion ==
(function() {}) as Foo;

[expect]
(function() {}) as Foo;

== should keep parentheses around function expression with satisfies assertion ==
(function() {}) satisfies Foo;

[expect]
(function() {}) satisfies Foo;

== should keep parentheses around function expression with as const assertion ==
(function() {}) as const;

[expect]
(function() {}) as const;

== should keep parentheses around function expression with non-null assertion ==
(function() {})!;

[expect]
(function() {})!;

== should keep parentheses around function expression with multiple assertions ==
(function() {}) as Foo as Bar;

[expect]
(function() {}) as Foo as Bar;

== should NOT add parentheses around arrow function with as assertion ==
(() => 42) as Foo;

[expect]
(() => 42) as Foo;

== should NOT add parentheses around call expression with as assertion ==
foo() as Bar;

[expect]
foo() as Bar;

== should keep parentheses around nested object literal with assertions ==
({prop: {}}) as Foo;

[expect]
({ prop: {} }) as Foo;

== should keep parentheses around object literal used as member expression base ==
({}).foo;

[expect]
({}).foo;

== should keep parentheses around object literal used as call expression callee ==
({})();

[expect]
({})();

== should keep parentheses around object literal used as optional chain base ==
({})?.prop;

[expect]
({})?.prop;

== should keep parentheses around function expression used as member expression base ==
(function() {}).foo;

[expect]
(function() {}).foo;

== should keep parentheses around function expression used as call expression callee ==
(function() {})();

[expect]
(function() {})();

== should keep parentheses around function expression used as optional chain base ==
(function() {})?.prop;

[expect]
(function() {})?.prop;

== should keep parentheses with mixed assertion wrappers on object literal ==
({})! as Foo;

[expect]
({})! as Foo;

== should keep parentheses with mixed assertion wrappers on function expression ==
(function() {})! as Foo;

[expect]
(function() {})! as Foo;

== should keep parentheses with chained mixed assertions on object literal ==
({}) as Foo satisfies Bar;

[expect]
({}) as Foo satisfies Bar;

== should keep parentheses with chained mixed assertions on function expression ==
(function() {}) as Foo satisfies Bar;

[expect]
(function() {}) as Foo satisfies Bar;

== should remove redundant outer parens from nested assertion chains on object literal ==
(({} as X) as Y);

[expect]
(({} as X) as Y);

== should remove redundant outer parens from nested assertion chains on function expression ==
((function() {}) as X) as Y;

[expect]
((function() {}) as X) as Y;

== should remove redundant outer parens from nested assertion chains on class expression ==
((class {}) as X) as Y;

[expect]
((class {}) as X) as Y;

== should keep parentheses around sequence expression ==
(a, b);

[expect]
(a, b);

== should keep parentheses around anonymous class expression ==
(class {});

[expect]
(class {});

== should keep parentheses around named class expression ==
(class Foo {});

[expect]
(class Foo {});

== should keep parentheses around class expression with as assertion ==
(class {}) as Foo;

[expect]
(class {}) as Foo;

== should keep parentheses around class expression with satisfies assertion ==
(class {}) satisfies Foo;

[expect]
(class {}) satisfies Foo;

== should keep parentheses around class expression with as const assertion ==
(class {}) as const;

[expect]
(class {}) as const;

== should keep parentheses around class expression with non-null assertion ==
(class {})!;

[expect]
(class {})!;

== should keep parentheses around class expression with multiple assertions ==
(class {}) as Foo as Bar;

[expect]
(class {}) as Foo as Bar;

== should keep parentheses with mixed assertion wrappers on class expression ==
(class {})! as Foo;

[expect]
(class {})! as Foo;

== should keep parentheses around class expression with chained mixed assertions ==
(class {}) as Foo satisfies Bar;

[expect]
(class {}) as Foo satisfies Bar;

== should keep parentheses around class expression used as member expression base ==
(class {}).foo;

[expect]
(class {}).foo;

== should keep parentheses around class expression used as call expression callee ==
(class {})();

[expect]
(class {})();

== should keep parentheses around class expression used as optional chain base ==
(class {})?.prop;

[expect]
(class {})?.prop;

== should retain parentheses with nested assignments in logical expression ==
if (this.leaving && (distanceL2 = (dlx = this.leaving.x - x) ** 2 + (dly = this.leaving.y - y) ** 2) > this.far2) {}

[expect]
if (this.leaving && (distanceL2 = (dlx = this.leaving.x - x) ** 2 + (dly = this.leaving.y - y) ** 2) > this.far2) {}

== should retain parentheses around simple nested assignment ==
const x = (y = 2);

[expect]
const x = (y = 2);

== should retain parentheses around type assertion with optional chaining ==
expect((result as Payload).options?.debug).toBe(true);

[expect]
expect((result as Payload).options?.debug).toBe(true);

== should retain parentheses around type assertion with optional chaining in assignment ==
const errorCode = (event.target as IDBOpenDBRequest).error?.name || 'Unknown';

[expect]
const errorCode = (event.target as IDBOpenDBRequest).error?.name || "Unknown";

== should retain parentheses around type assertion with method call ==
return Object.keys(object).every(key => (keys as string[]).includes(key));

[expect]
return Object.keys(object).every(key => (keys as string[]).includes(key));

== should retain parentheses around negation of in expression ==
const onlyColor = computed(() => 'color' in props.colorData && !('word' in props.colorData));

[expect]
const onlyColor = computed(() => "color" in props.colorData && !("word" in props.colorData));

== should retain parentheses around negation of in expression with member access ==
const onlyWord = computed(() => !('color' in props.colorData) && 'word' in props.colorData);

[expect]
const onlyWord = computed(() => !("color" in props.colorData) && "word" in props.colorData);

== should retain parentheses around identifier in ternary operator ==
const errorTitle = computed(() => 'Fehler' + (anyErrors.value ? '' : '(leer)'));

[expect]
const errorTitle = computed(() => "Fehler" + (anyErrors.value ? "" : "(leer)"));

== should retain parentheses around complex arithmetic expression ==
const duration = computed(() => (props.data.entries.flatMap(x => x.log[x.log.length - 1].t - x.log[0].t).reduce((a, b) => a + b) / 1000).toString());

[expect]
const duration = computed(() =>
    (props.data.entries.flatMap(x => x.log[x.log.length - 1].t - x.log[0].t).reduce((a, b) => a + b) / 1000).toString()
);

== should retain parentheses around negation of instanceof expression ==
const isNotInstance = !(obj instanceof MyClass);

[expect]
const isNotInstance = !(obj instanceof MyClass);

== should retain parentheses around negation of comparison expression ==
const isNotLess = !(a < b);

[expect]
const isNotLess = !(a < b);

== should retain parentheses around negation of equality expression ==
const isNotEqual = !(a == b);

[expect]
const isNotEqual = !(a == b);

== should retain parentheses around negation of strict equality expression ==
const isNotStrictEqual = !(a === b);

[expect]
const isNotStrictEqual = !(a === b);

== should retain parentheses around negation of addition expression ==
const notSum = !(a + b);

[expect]
const notSum = !(a + b);

== should retain parentheses around negation of subtraction expression ==
const notDiff = !(a - b);

[expect]
const notDiff = !(a - b);

== should retain parentheses around negation of logical and expression ==
const notBoth = !(a && b);

[expect]
const notBoth = !(a && b);

== should retain parentheses around negation of logical or expression ==
const notEither = !(a || b);

[expect]
const notEither = !(a || b);

== should retain parentheses around typeof with binary expression ==
const typeOfSum = typeof (a + b);

[expect]
const typeOfSum = typeof (a + b);

== should retain parentheses around void with logical and expression ==
const voidResult = void (a && b);

[expect]
const voidResult = void (a && b);

== should retain parentheses around unary minus with exponentiation ==
const negativeSquared = (-2) ** 3;

[expect]
const negativeSquared = (-2) ** 3;

== should retain parentheses around unary plus with exponentiation ==
const positiveSquared = (+x) ** 2;

[expect]
const positiveSquared = (+x) ** 2;

== should retain parentheses around typeof with exponentiation ==
const typeofExp = (typeof x) ** 2;

[expect]
const typeofExp = (typeof x) ** 2;

== should retain parentheses around void with exponentiation ==
const voidExp = (void 0) ** 2;

[expect]
const voidExp = (void 0) ** 2;

== should retain parentheses around bitwise not with exponentiation ==
const bitwiseNotExp = (~flags) ** 2;

[expect]
const bitwiseNotExp = (~flags) ** 2;

== should retain parentheses around logical not with exponentiation ==
const logicalNotExp = (!flag) ** 2;

[expect]
const logicalNotExp = (!flag) ** 2;

== should retain parentheses around delete with exponentiation ==
const deleteExp = (delete obj.prop) ** 2;

[expect]
const deleteExp = (delete obj.prop) ** 2;

== should retain parentheses around await with exponentiation ==
async function test() {
  const awaitExp = (await getValue()) ** 2;
}

[expect]
async function test() {
    const awaitExp = (await getValue()) ** 2;
}

== should retain parentheses for left-to-right exponentiation (associativity override) ==
const leftToRight = (2 ** 3) ** 2;

[expect]
const leftToRight = (2 ** 3) ** 2;

== should retain parentheses for right-to-left exponentiation (preserve user intent) ==
const rightToLeft = 2 ** (3 ** 2);

[expect]
const rightToLeft = 2 ** (3 ** 2);

== should retain required parentheses around spread with conditional expression ==
const o = {
  ...(flag ? {} : {
      key: {
        value: flag || defaultValue
      }
    })
};

[expect]
const o = {
    ...(flag ? {} : {
        key: {
            value: flag || defaultValue,
        },
    }),
};

== should retain required parentheses around type assertion on left side of assignment ==
(obj.prop as unknown) = {
  handler: (data: string) => {
    processData(data);
  }
};

[expect]
(obj.prop as unknown) = {
    handler: (data: string) => {
        processData(data);
    },
};

== should retain required parentheses around spread with sequence expression ==
const o = {
  ...(a, b)
};

[expect]
const o = {
    ...(a, b),
};

== should retain required parentheses around object destructuring assignment ==
({x} = obj);

[expect]
({ x } = obj);

== should retain required parentheses around object destructuring assignment with trailing comment ==
({x} = obj); // comment

[expect]
({ x } = obj); // comment

== should retain parentheses around array destructuring assignment ==
([a] = arr);

[expect]
([a] = arr);

== should retain required parentheses around assignment with member access in while condition ==
while ((current = startElement.previousSibling!)._offset! >= threshold && current !== endElement)
  process(current);

[expect]
while ((current = startElement.previousSibling!)._offset! >= threshold && current !== endElement) {
    process(current);
}

== should retain required parentheses around assignment with member access and multiple conditions ==
while (
  (current = firstElement.nextSibling!)._offset! + current!.height < targetValue
  && current !== lastElement && current.nextSibling !== lastElement
)
  process(current);

[expect]
while (
    (current = firstElement.nextSibling!)._offset! + current!.height < targetValue
    && current !== lastElement && current.nextSibling !== lastElement
) {
    process(current);
}

== should retain parentheses around assignment in comparison in while condition ==
while ((item = getNext()) !== null)
  process(item);

[expect]
while ((item = getNext()) !== null) {
    process(item);
}

== should retain required parentheses around assignment with call ==
(fn = () => 42)();

[expect]
(fn = () => 42)();

== should retain required parentheses around assignment with optional call ==
(maybeFn = () => 99)?.();

[expect]
(maybeFn = () => 99)?.();

== should retain required parentheses around assignment with computed member access ==
(obj = {x: 5, y: 10})["x"];

[expect]
(obj = { x: 5, y: 10 })["x"];

== should retain required parentheses around assignment with optional computed member access ==
(obj = getValue())?.[key];

[expect]
(obj = getValue())?.[key];

== should retain required parentheses around assignment with new expression ==
const instance = new (Constructor = MyClass)();

[expect]
const instance = new (Constructor = MyClass)();

== should retain required parentheses around assignment with non-null assertion ==
const result = (maybeValue = getValue())!;

[expect]
const result = (maybeValue = getValue())!;

== should retain required parentheses around assignment with type assertion ==
const result = (value = 5) as number;

[expect]
const result = (value = 5) as number;

== should retain parentheses around arrow function in logical expression ==
f(a() || (() => ""));

[expect]
f(a() || (() => ""));

== should retain parentheses around assignment with member access in logical expression ==
f(!a || !(b = a!.b));

[expect]
f(!a || !(b = a!.b));

== should retain parentheses around arrow function with type annotation in logical expression ==
f(a && ((b: string) => c!(a)));

[expect]
f(a && ((b: string) => c!(a)));

== should retain parentheses around type assertion in extends clause ==
return class extends (a as typeof B) {};

[expect]
return class extends (a as typeof B) {};

== should retain parentheses around type assertion followed by call ==
proxy[key] = (...args: any[]) => (ls[key] as (...args: any[]) => any)(...args);

[expect]
proxy[key] = (...args: any[]) => (ls[key] as (...args: any[]) => any)(...args);

== should retain parentheses around assignment with new expression ==
return a || (a = new (X as any)());

[expect]
return a || (a = new (X as any)());

== should retain parentheses around arrow function in variable declarator ==
const x = (a => a);

[expect]
const x = (a => a);

== should retain parentheses for call expression after nullish coalescing ==
(a.b ?? c)(d);

[expect]
(a.b ?? c)(d);

== should retain parentheses around logical expression before nullish coalescing ==
(a && b(c)?.d) ?? "...";

[expect]
(a && b(c)?.d) ?? "...";

== should retain parentheses in new expression with logical assignment ==
new (A || (A = b.c()))(d);

[expect]
new (A || (A = b.c()))(d);

== should retain parentheses for call expression after logical OR ==
a = (b || c)(d);

[expect]
a = (b || c)(d);

== should retain parentheses for call expression after member and logical OR ==
(a.b || c)(d);

[expect]
(a.b || c)(d);

== should retain parentheses for nullish coalescing with logical AND in ternary ==
return a.b ? (a.b && f(a.b, d)) ?? (a.c && f(a.c, d)) : undefined;

[expect]
return a.b ? (a.b && f(a.b, d)) ?? (a.c && f(a.c, d)) : undefined;

== should retain parentheses for member access after logical OR ==
(a || b).c

[expect]
(a || b).c;

== should retain parentheses for computed member access after logical AND ==
(a && b)[c]

[expect]
(a && b)[c];

== should retain parentheses for member access after nullish coalescing ==
(a ?? b).c

[expect]
(a ?? b).c;

== should retain parentheses around addition with non-null assertion before comparison ==
(a + b!) === x

[expect]
(a + b!) === x;

== should retain parentheses around non-null assertion before loose equality ==
(a + b!) == x

[expect]
(a + b!) == x;

== should retain parentheses around non-null assertion before assignment ==
let y = (a + b!) = x;

[expect]
let y = (a + b!) = x;

== should retain parentheses around direct non-null assertion before assignment ==
(x!) = y;

[expect]
(x!) = y;

== should retain all parentheses for nested comparisons ==
(a !== b || c === (d === e))

[expect]
(a !== b || c === (d === e));

== should retain parentheses in associative addition ==
const x = a + (b + c);

[expect]
const x = a + (b + c);

== should retain parentheses in left-associative addition ==
const x = (a + b) + c;

[expect]
const x = (a + b) + c;

== should retain parentheses in left-associative subtraction ==
const x = (a - b) - c;

[expect]
const x = (a - b) - c;

== should retain parentheses in left-associative multiplication ==
const x = (a * b) * c;

[expect]
const x = (a * b) * c;

== should retain parentheses in left-associative division ==
const x = (a / b) / c;

[expect]
const x = (a / b) / c;

== should retain parentheses around conditional expression after unary operator ==
!(a ? b : c)

[expect]
!(a ? b : c);

== should retain parentheses around sequence expression after unary operator ==
!(a, b)

[expect]
!(a, b);

== should retain parentheses around arrow function after unary operator ==
!(x => x)

[expect]
!(x => x);

== should retain parentheses around yield expression after unary operator ==
function* test() {
    return !(yield a);
}

[expect]
function* test() {
    return !(yield a);
}

== should retain parentheses around assignment in unary expression ==
!(a = b)

[expect]
!(a = b);

== should retain parentheses around binary expression after unary operator ==
!(a + b)

[expect]
!(a + b);

== should retain parentheses around logical OR after unary operator ==
!(a || b)

[expect]
!(a || b);

== should retain parentheses around nullish coalescing after unary operator ==
!(a ?? b)

[expect]
!(a ?? b);
