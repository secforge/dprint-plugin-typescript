~~ expressionStatement.useParentheses: preferNone ~~
== should remove parentheses inside call arguments ==
f((1 + 2));

[expect]
f(1 + 2);

== should remove parentheses inside return statement ==
function test() {
    return (value);
}

[expect]
function test() {
    return value;
}

== should keep parentheses when they affect operator precedence ==
const result = (a + b) * c;

[expect]
const result = (a + b) * c;

== should retain parentheses that enforce grouping ==
const ambiguous = a / (b * c);

[expect]
const ambiguous = a / (b * c);

== should remove parentheses that do not affect precedence ==
const precedenceOk = (a * b) + c;

[expect]
const precedenceOk = a * b + c;

== should remove parentheses in ternary branches ==
const value = condition ? (left) : (right);

[expect]
const value = condition ? left : right;

== should remove parentheses inside array elements ==
const items = [(value), ((other))];

[expect]
const items = [value, other];

== should retain parentheses in array destructuring pattern when required ==
const [value = (await load())] = source;

[expect]
const [value = (await load())] = source;

== should remove parentheses inside object properties ==
const obj = {
    prop: (value),
    nested: ((other)),
};

[expect]
const obj = {
    prop: value,
    nested: other,
};

== should keep parentheses around object literal arrow body ==
const arrow = () => ({ value: 1 });

[expect]
const arrow = () => ({ value: 1 });

== should remove parentheses inside template expression ==
const message = `hello ${ (name) }`;

[expect]
const message = `hello ${name}`;

== should remove parentheses around optional chaining ==
const maybe = (obj?.prop);

[expect]
const maybe = obj?.prop;

== should retain parentheses around optional chaining when combined with exponentiation ==
const complex = (obj?.value) ** 2;

[expect]
const complex = (obj?.value) ** 2;

== should keep parentheses around function expression callees ==
const iifeResult = (function () {})();

[expect]
const iifeResult = (function() {})();

== should keep parentheses around optional chained function expression callees ==
const optionalIife = (function () {})?.();

[expect]
const optionalIife = (function() {})?.();

== should keep parentheses around optional chained arrow callees ==
const optionalArrowIife = (() => {})?.();

[expect]
const optionalArrowIife = (() => {})?.();

== should remove redundant parens in nested optional arrow calls ==
const nestedOptionalArrow = ((() => {})?.())?.();

[expect]
const nestedOptionalArrow = (() => {})?.()?.();

== should keep parentheses around optional chained class expression callees ==
const optionalClassIife = (class {})?.();

[expect]
const optionalClassIife = (class {})?.();

== should keep parentheses around optional chained class expression property access ==
const optionalClassProp = (class { constructor() { this.prop = 1; } })?.prop;

[expect]
const optionalClassProp = (class {
    constructor() {
        this.prop = 1;
    }
})?.prop;

== should keep parentheses around optional chained function expression property access ==
const optionalFuncProp = (function () {})?.prop;

[expect]
const optionalFuncProp = (function() {})?.prop;

== should keep parentheses around optional chained arrow function property access ==
const optionalArrowProp = (() => {})?.prop;

[expect]
const optionalArrowProp = (() => {})?.prop;

== should keep parentheses around multi-line function expression property access (1st pass) ==
const functionPropMultiline = (function () {}
    ).prop;

[expect]
const functionPropMultiline = (function() {}).prop;

== should keep parentheses around multi-line function expression property access (2nd pass) ==
const functionPropMultiline = (function() {}).prop;

[expect]
const functionPropMultiline = (function() {}).prop;

== should keep parentheses around multi-line class expression property access (1st pass) ==
const classPropMultiline = (class {}
    ).prop;

[expect]
const classPropMultiline = (class {}).prop;

== should keep parentheses around multi-line class expression property access (2nd pass) ==
const classPropMultiline = (class {}).prop;

[expect]
const classPropMultiline = (class {}).prop;

== should keep parentheses around multi-line arrow function property access (1st pass) ==
const arrowPropMultiline = (() => {}
    ).prop;

[expect]
const arrowPropMultiline = (() => {}).prop;

== should keep parentheses around multi-line arrow function property access (2nd pass) ==
const arrowPropMultiline = (() => {}).prop;

[expect]
const arrowPropMultiline = (() => {}).prop;

== should keep parentheses around multi-line optional chained function property access (1st pass) ==
const optionalFunctionPropMultiline = (function () {}
    )?.prop;

[expect]
const optionalFunctionPropMultiline = (function() {})?.prop;

== should keep parentheses around multi-line optional chained function property access (2nd pass) ==
const optionalFunctionPropMultiline = (function() {})?.prop;

[expect]
const optionalFunctionPropMultiline = (function() {})?.prop;

== should keep parentheses around multi-line optional chained function property access with comment (1st pass) ==
const optionalFunctionPropMultilineComment = (function () {}
    )?.prop; // comment

[expect]
const optionalFunctionPropMultilineComment = (function() {})?.prop; // comment

== should keep parentheses around multi-line optional chained function property access with comment (2nd pass) ==
const optionalFunctionPropMultilineComment = (function() {})?.prop; // comment

[expect]
const optionalFunctionPropMultilineComment = (function() {})?.prop; // comment

== should keep parentheses around multi-line optional chained arrow call (1st pass) ==
const optionalArrowCallMultiline = (() => {}
    )?.();

[expect]
const optionalArrowCallMultiline = (() => {})?.();

== should keep parentheses around multi-line optional chained arrow call (2nd pass) ==
const optionalArrowCallMultiline = (() => {})?.();

[expect]
const optionalArrowCallMultiline = (() => {})?.();

== should keep parentheses around multi-line optional chained function call (1st pass) ==
const optionalFunctionCallMultiline = (function () {}
    )?.();

[expect]
const optionalFunctionCallMultiline = (function() {})?.();

== should keep parentheses around multi-line optional chained function call (2nd pass) ==
const optionalFunctionCallMultiline = (function() {})?.();

[expect]
const optionalFunctionCallMultiline = (function() {})?.();

== should remove redundant parens around optional chained new expression access ==
const optionalNewProp = (new Foo())?.prop;

[expect]
const optionalNewProp = new Foo()?.prop;

== should keep parentheses around multi-line optional chained new expression access ==
const optionalNewPropMultiline = (new Foo
    ())?.prop;

[expect]
const optionalNewPropMultiline = new Foo()?.prop;

== should remove parentheses around nullish coalescing inside assignments ==
const fallback = (primary ?? secondary);

[expect]
const fallback = primary ?? secondary;

== should remove parentheses around await inside expressions ==
async function load() {
    const data = (await fetchData());
}

[expect]
async function load() {
    const data = await fetchData();
}

== should keep parentheses around awaited call when accessing members ==
async function useData() {
    return (await loadData()).map(item => item);
}

[expect]
async function useData() {
    return (await loadData()).map(item => item);
}

== should remove parentheses around yield expression ==
function* gen() {
    yield (value);
}

[expect]
function* gen() {
    yield value;
}

== should retain parentheses around yield used in expression ==
function* collect() {
    const collected = [ (yield value) ];
}

[expect]
function* collect() {
    const collected = [(yield value)];
}

== should keep parentheses around yield when accessing members ==
function* project() {
    const result = (yield getValue()).prop;
}

[expect]
function* project() {
    const result = (yield getValue()).prop;
}

== should keep parentheses around multi-line yield expression ==
function* yieldMultiline() {
    yield (getGenerator
        ());
}

[expect]
function* yieldMultiline() {
    yield getGenerator();
}

== should keep parentheses around multi-line yield optional call (1st pass) ==
function* yieldOptionalMultiline() {
    return (yield getFactory
        ())?.();
}

[expect]
function* yieldOptionalMultiline() {
    return (yield getFactory())?.();
}

== should keep parentheses around multi-line yield optional call (2nd pass) ==
function* yieldOptionalMultiline() {
    return (yield getFactory())?.();
}

[expect]
function* yieldOptionalMultiline() {
    return (yield getFactory())?.();
}

== should keep parentheses around multi-line yield property access (1st pass) ==
function* yieldPropertyMultiline() {
    return (yield getFactory
        ()).value;
}

[expect]
function* yieldPropertyMultiline() {
    return (yield getFactory()).value;
}

== should keep parentheses around multi-line yield property access (2nd pass) ==
function* yieldPropertyMultiline() {
    return (yield getFactory()).value;
}

[expect]
function* yieldPropertyMultiline() {
    return (yield getFactory()).value;
}

== should remove parentheses around throw expression ==
throw (error);

[expect]
throw error;

== should keep parentheses around multi-line throw expression ==
function throwMultiline() {
    throw (createError
        ());
}

[expect]
function throwMultiline() {
    throw createError();
}

== should keep parentheses around multi-line await expression in throw ==
async function throwAwaitMultiline() {
    throw (await createAsyncError
        ());
}

[expect]
async function throwAwaitMultiline() {
    throw await createAsyncError();
}

== should keep parentheses around multi-line throw optional call ==
function throwOptionalMultiline() {
    throw (getFactory
        ())?.();
}

[expect]
function throwOptionalMultiline() {
    throw getFactory()?.();
}

== should keep parentheses around multi-line throw property access ==
function throwPropertyMultiline() {
    throw (createError
        ()).code;
}

[expect]
function throwPropertyMultiline() {
    throw createError().code;
}

== should retain parentheses around throw in IIFE ==
const result = condition ? value : (() => { throw error; })();

[expect]
const result = condition ? value : (() => {
    throw error;
})();

== should remove parentheses around export default expression ==
export default (component);

[expect]
export default component;

== should retain parentheses around export default when template literal ==
export default (`value`);

[expect]
export default (`value`);

== should remove parentheses in if condition ==
if ((condition)) {
    doSomething();
}

[expect]
if (condition) {
    doSomething();
}

== should keep parentheses around multi-line await in if condition ==
async function ifAwaitMultiline() {
    if ((await shouldProceed
        ())) {
        doSomething();
    }
}

[expect]
async function ifAwaitMultiline() {
    if (await shouldProceed()) {
        doSomething();
    }
}

== should remove parentheses in while condition ==
while ((ready)) {
    run();
}

[expect]
while (ready) {
    run();
}

== should remove parentheses in do while condition ==
do {
    work();
} while ((shouldContinue));

[expect]
do {
    work();
} while (shouldContinue);

== should keep parentheses around multi-line await in while condition ==
async function whileAwaitMultiline() {
    while ((await shouldContinue
        ())) {
        run();
    }
}

[expect]
async function whileAwaitMultiline() {
    while (await shouldContinue()) {
        run();
    }
}

== should remove parentheses in for-of iterable ==
for (const item of (collection)) {
    consume(item);
}

[expect]
for (const item of collection) {
    consume(item);
}

== should keep parentheses around multi-line await in for-of iterable ==
async function forOfAwaitMultiline() {
    for (const item of (await loadItems
        ())) {
        consume(item);
    }
}

[expect]
async function forOfAwaitMultiline() {
    for (const item of await loadItems()) {
        consume(item);
    }
}

== should remove parentheses in for head ==
for (let i = (0); i < (max); i++) {
    step(i);
}

[expect]
for (let i = 0; i < max; i++) {
    step(i);
}

== should remove parentheses in switch discriminant and cases ==
switch ((value)) {
case (1):
    break;
}

[expect]
switch (value) {
    case 1:
        break;
}

== should remove parentheses around unary operations ==
const increment = (++(value));

[expect]
const increment = ++value;

== should remove parentheses around typeof in binary expressions ==
const typeCheck = (typeof value) + " suffix";

[expect]
const typeCheck = typeof value + " suffix";

== should keep parentheses around delete when followed by member access ==
const deleteResult = (delete obj.prop).toString();

[expect]
const deleteResult = (delete obj.prop).toString();

== should keep parentheses around typeof when accessing members ==
const typeInfo = (typeof value).toUpperCase();

[expect]
const typeInfo = (typeof value).toUpperCase();

== should keep parentheses around void when accessing members ==
const voidInfo = (void 0).toString();

[expect]
const voidInfo = (void 0).toString();

== should remove parentheses in default parameter initializers ==
function configure(option = (defaultValue)) {}

[expect]
function configure(option = defaultValue) {}

== should remove parentheses inside logical expressions ==
const combined = (a && b) || (c && d);

[expect]
const combined = a && b || c && d;

== should retain parentheses in logical expression when required ==
const precedence = a && (b || c);

[expect]
const precedence = a && (b || c);

== should remove parentheses around new expression ==
const instance = (new Foo());

[expect]
const instance = new Foo();

== should retain parentheses around new with call when needed ==
const construct = (new Foo())();

[expect]
const construct = (new Foo())();

== should remove parentheses around typeof/void/delete ==
const info = {
    type: typeof (value),
    cleared: void (0),
    removed: delete (obj.prop),
};

[expect]
const info = {
    type: typeof value,
    cleared: void 0,
    removed: delete obj.prop,
};

== should remove parentheses around tagged template expressions ==
const tagged = tag((value));

[expect]
const tagged = tag(value);

== should remove parentheses inside class field initializer ==
class Example {
    value = (initial);
}

[expect]
class Example {
    value = initial;
}

== should remove parentheses in array destructuring defaults ==
const [first = (fallback)] = source;

[expect]
const [first = fallback] = source;

== should remove parentheses in object destructuring defaults ==
const { value = (fallback) } = source;

[expect]
const { value = fallback } = source;

== should remove parentheses around dynamic import specifier ==
async function load() {
    return import((moduleName));
}

[expect]
async function load() {
    return import(moduleName);
}

== should retain parentheses around dynamic import with assertions ==
async function load() {
    return import(moduleName, { with: (options) });
}

[expect]
async function load() {
    return import(moduleName, { with: options });
}

== should remove parentheses around class heritage ==
class Derived extends (Base) {}

[expect]
class Derived extends Base {}

== should remove parentheses in super call ==
class Child extends Base {
    constructor() {
        super((arg));
    }
}

[expect]
class Child extends Base {
    constructor() {
        super(arg);
    }
}

== should remove parentheses around yield star expression ==
function* forward() {
    yield* (iterable);
}

[expect]
function* forward() {
    yield* iterable;
}

== should keep parentheses around multi-line yield star expression ==
function* forwardMultiline() {
    yield* (getIterable
        ());
}

[expect]
function* forwardMultiline() {
    yield* getIterable();
}

== should keep parentheses around sequence expressions ==
doSomething((a, b));

[expect]
doSomething((a, b));

== should remove parentheses around call expression results ==
const resultCall = (compute()) + 1;

[expect]
const resultCall = compute() + 1;

== should remove parentheses around expressions in for loop headers ==
for (let i = (0); i < (max); i++) {}

[expect]
for (let i = 0; i < max; i++) {}

== should retain parentheses when mixing nullish coalescing with logical OR ==
const fallbackOr = (x ?? y) || z;

[expect]
const fallbackOr = (x ?? y) || z;

== should retain parentheses when mixing nullish coalescing with logical AND ==
const fallbackAnd = (x ?? y) && z;

[expect]
const fallbackAnd = (x ?? y) && z;

== should retain parentheses when mixing logical OR with nullish coalescing ==
const orWithNull = x || (y ?? z);

[expect]
const orWithNull = x || (y ?? z);

== should retain parentheses when mixing logical AND with nullish coalescing ==
const andWithNull = x && (y ?? z);

[expect]
const andWithNull = x && (y ?? z);

== should remove parentheses around delete in logical expressions ==
const deleteCheck = (delete obj.prop) && other;

[expect]
const deleteCheck = delete obj.prop && other;

== should remove parentheses around typeof in binary expressions ==
const typeCheck = (typeof value) + " suffix";

[expect]
const typeCheck = typeof value + " suffix";

== should remove parentheses around void in logical expressions ==
const voidCheck = (void 0) || fallback;

[expect]
const voidCheck = void 0 || fallback;

== should keep parentheses around await in binary expressions ==
async function asyncBinary() {
    const result = (await fetch()) + 1;
}

[expect]
async function asyncBinary() {
    const result = (await fetch()) + 1;
}

== should remove redundant parentheses around await when returned ==
async function returnAwait(condition) {
    return (await resolveValue(condition));
}

[expect]
async function returnAwait(condition) {
    return await resolveValue(condition);
}

== should keep parentheses around multi-line return call ==
function returnMultilineCall() {
    return (getFactory
        ());
}

[expect]
function returnMultilineCall() {
    return getFactory();
}

== should keep parentheses around multi-line return call with comment ==
function returnMultilineCallWithComment() {
    return (createFactory // comment
        ());
}

[expect]
function returnMultilineCallWithComment() {
    return createFactory // comment
    ();
}

== should keep parentheses around multi-line throw call with comment ==
function throwMultilineWithComment() {
    throw (createError // comment
        ());
}

[expect]
function throwMultilineWithComment() {
    throw createError // comment
    ();
}

== should keep parentheses around multi-line await expression (1st pass) ==
async function awaitMultiline() {
    return (await loadData
        ()).map(item => item);
}

[expect]
async function awaitMultiline() {
    return (await loadData()).map(item => item);
}

== should keep parentheses around multi-line await expression (2nd pass) ==
async function awaitMultiline() {
    return (await loadData()).map(item => item);
}

[expect]
async function awaitMultiline() {
    return (await loadData()).map(item => item);
}

== should keep parentheses around multi-line await optional call (1st pass) ==
async function awaitOptionalMultiline() {
    return (await loadFactory
        ())?.();
}

[expect]
async function awaitOptionalMultiline() {
    return (await loadFactory())?.();
}

== should keep parentheses around multi-line await optional call (2nd pass) ==
async function awaitOptionalMultiline() {
    return (await loadFactory())?.();
}

[expect]
async function awaitOptionalMultiline() {
    return (await loadFactory())?.();
}

== should keep parentheses around multi-line await binary expression (1st pass) ==
async function awaitBinaryMultiline() {
    const total = (await computeValue
        ()) + 1;
    return total;
}

[expect]
async function awaitBinaryMultiline() {
    const total = (await computeValue()) + 1;
    return total;
}

== should keep parentheses around multi-line await binary expression (2nd pass) ==
async function awaitBinaryMultiline() {
    const total = (await computeValue()) + 1;
    return total;
}

[expect]
async function awaitBinaryMultiline() {
    const total = (await computeValue()) + 1;
    return total;
}

== should keep parentheses around multi-line return property access (1st pass) ==
function returnPropertyMultiline() {
    return (getObject
        ()).value;
}

[expect]
function returnPropertyMultiline() {
    return getObject().value;
}

== should keep parentheses around multi-line return property access (2nd pass) ==
function returnPropertyMultiline() {
    return getObject().value;
}

[expect]
function returnPropertyMultiline() {
    return getObject().value;
}

== should keep parentheses around multi-line return optional call ==
function returnOptionalMultiline() {
    return (getCallback
        ())?.();
}

[expect]
function returnOptionalMultiline() {
    return getCallback()?.();
}

== should keep parentheses around multi-line return property access with comment ==
function returnPropertyMultilineComment() {
    return (getObject // comment
        ()).value;
}

[expect]
function returnPropertyMultilineComment() {
    return getObject // comment
    ().value;
}

== should remove redundant parentheses around await in ternary expressions ==
async function asyncTernary() {
    const value = condition ? (await foo()) : bar;
}

[expect]
async function asyncTernary() {
    const value = condition ? await foo() : bar;
}

== should retain parentheses around yield in binary expressions ==
function* yieldBinary() {
    const result = (yield value) + 1;
}

[expect]
function* yieldBinary() {
    const result = (yield value) + 1;
}

== should keep parentheses around multi-line yield binary expression ==
function* yieldBinaryMultiline() {
    const result = (yield computeValue
        ()) + 1;
    return result;
}

[expect]
function* yieldBinaryMultiline() {
    const result = (yield computeValue()) + 1;
    return result;
}

== should remove redundant parens around member access on await in ternary condition ==
async function ternaryAccess(cond) {
    return ((await fetchData()).value) ? (await fetchData()).value : defaultValue;
}

[expect]
async function ternaryAccess(cond) {
    return (await fetchData()).value ? (await fetchData()).value : defaultValue;
}
